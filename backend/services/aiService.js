import axios from "axios";

const GEMINI_API_KEY = process.env.GEMINI_API_KEY;
const GEMINI_MODEL = process.env.GEMINI_MODEL || "gemini-2.5-flash";

// Base URL for Gemini v1 HTTP API
const GEMINI_URL = `https://generativelanguage.googleapis.com/v1/models/${GEMINI_MODEL}:generateContent`;

/**
 * Low-level helper: call Gemini HTTP API with a text prompt,
 * return the raw text output.
 */
async function callGemini(prompt) {
  if (!GEMINI_API_KEY) {
    throw new Error("GEMINI_API_KEY is not set in .env");
  }

  const res = await axios.post(
    `${GEMINI_URL}?key=${GEMINI_API_KEY}`,
    {
      contents: [
        {
          parts: [{ text: prompt }]
        }
      ]
    }
  );

  // Standard v1 response format:
  // res.data.candidates[0].content.parts[0].text
  const candidates = res.data.candidates;
  if (!candidates || !candidates.length) {
    throw new Error("No candidates returned from Gemini");
  }

  const parts = candidates[0].content?.parts;
  if (!parts || !parts.length || !parts[0].text) {
    throw new Error("No text content in Gemini response");
  }

  return parts[0].text;
}

/**
 * Utility: extract first JSON object from a text blob.
 */
function extractJson(raw) {
  const match = raw.match(/(\{[\s\S]*\})/);
  if (!match) {
    throw new Error("No JSON object found in model output");
  }
  return JSON.parse(match[1]);
}

/**
 * Compose vendor email text (unchanged).
 */
export const composeVendorEmail = (rfp, vendor) => {
  const lines = [];
  lines.push(`Hello ${vendor.name},`);
  lines.push("");
  lines.push(`We are seeking quotations for the following RFP: ${rfp.title || "Procurement Request"}`);
  lines.push(`Description: ${rfp.description || ""}`);
  lines.push("");
  lines.push("Items:");
  (rfp.line_items || []).forEach((it) => {
    lines.push(
      `- ${it.name}: qty ${it.required_qty} ${it.unit || "kg"}, quality: ${
        it.quality_spec || ""
      }`
    );
  });
  lines.push("");
  lines.push(`Budget: ${rfp.budget?.amount || ""} ${rfp.budget?.currency || "INR"}`);
  lines.push(`Delivery within ${rfp.delivery_days || ""} days`);
  lines.push(`Payment terms: ${rfp.payment_terms || ""}`);
  lines.push("");
  lines.push("Please reply with your quotation (PDF or text) and include unit prices, lead times, and quality.");
  lines.push("");
  lines.push("Regards, Procurement Team");

  return lines.join("\n");
};

/**
 * NLP → Structured RFP using Gemini
 */
export const generateRFPFromText = async (text) => {
  const prompt = `
You are helping a procurement manager in an FMCG company.

Convert the following natural-language RFP into a structured JSON object.

Return ONLY JSON, no explanation, with this schema:

{
  "title": string,
  "description": string,
  "budget_amount": number | null,
  "budget_currency": string | null,
  "delivery_days": number | null,
  "payment_terms": string | null,
  "line_items": [
    {
      "name": string,
      "required_qty": number | null,
      "quality_spec": string | null
    }
  ],
  "notes": string | null
}

Natural language RFP:
"""${text}"""
`;

  try {
    const raw = await callGemini(prompt);
    const parsed = extractJson(raw);

    return {
      title: parsed.title || "RFP (Gemini Generated)",
      description: parsed.description || text,
      budget_amount: parsed.budget_amount ?? null,
      budget_currency: parsed.budget_currency || "INR",
      delivery_days: parsed.delivery_days ?? null,
      payment_terms: parsed.payment_terms || null,
      line_items: Array.isArray(parsed.line_items) ? parsed.line_items : [],
      notes: parsed.notes || null
    };
  } catch (err) {
    console.warn("⚠ Gemini RFP extraction failed, using fallback:", err.message);

    // Your sugar + honey fallback for demo
    return {
      title: "RFP (Fallback)",
      description: text,
      budget_amount: 1000000,
      budget_currency: "INR",
      delivery_days: 7,
      payment_terms: "Net 30",
      line_items: [
        { name: "Sugar", required_qty: 1000, quality_spec: "Grade B" },
        { name: "Honey", required_qty: 100, quality_spec: "Grade A" }
      ],
      notes: "Generated by fallback due to AI error"
    };
  }
};

/**
 * AI vendor scoring using Gemini.
 */
export const llmScoreVendor = async (rfp, vendorResponse) => {
  const prompt = `
You are a senior FMCG procurement expert.

Evaluate the following vendor proposal strictly against the RFP.

--- RFP ---
${JSON.stringify(rfp, null, 2)}

--- Vendor Response ---
${JSON.stringify(vendorResponse, null, 2)}

Scoring rubric (0–100 total):
- Quality match vs required grade/spec: 40%
- Quantity fulfillment vs required quantity: 25%
- Delivery time vs delivery_days: 20%
- Price vs budget (lower is better): 10%
- Payment terms vs RFP payment_terms: 5%

Return ONLY JSON:

{
  "score": number,       // 0..100
  "reasons": [
    "short reason 1",
    "short reason 2"
  ]
}
`;

  try {
    const raw = await callGemini(prompt);
    const parsed = extractJson(raw);

    return {
      score: typeof parsed.score === "number" ? parsed.score : 0,
      reasons: Array.isArray(parsed.reasons)
        ? parsed.reasons
        : ["No reasons provided by model"]
    };
  } catch (err) {
    console.warn("⚠ Gemini vendor scoring failed, using fallback:", err.message);
    return {
      score: 50,
      reasons: ["Fallback scoring used due to AI error"]
    };
  }
};
