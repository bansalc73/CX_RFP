import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI(process.env.GEMINI_API_KEY);
const geminiModel = genAI.getGenerativeModel({ model: "gemini-1.5-flash" });

// helper: call Gemini and return raw text
const callGemini = async (prompt) => {
  const result = await geminiModel.generateContent(prompt);
  return result.response.text();
};

// small helper: safe JSON extraction from LLM text
const extractJson = (raw) => {
  const match = raw.match(/(\{[\s\S]*\})/);
  if (!match) {
    throw new Error("No JSON object found in model output");
  }
  return JSON.parse(match[1]);
};




/* Compose simple vendor email (string) */
export const composeVendorEmail = (rfp, vendor) => {
  const lines = [];
  lines.push(`Hello ${vendor.name},`);
  lines.push("");
  lines.push(`We are seeking quotations for the following RFP: ${rfp.title || "Procurement Request"}`);
  lines.push(`Description: ${rfp.description || ""}`);
  lines.push("");
  lines.push("Items:");
  (rfp.line_items || []).forEach(it => {
    lines.push(`- ${it.name}: qty ${it.required_qty} ${it.unit || 'kg'}, quality: ${it.quality_spec || ''}`);
  });
  lines.push("");
  lines.push(`Budget: ${rfp.budget?.amount || ""} ${rfp.budget?.currency || "INR"}`);
  lines.push(`Delivery within ${rfp.delivery_days || ""} days`);
  lines.push(`Payment terms: ${rfp.payment_terms || ""}`);
  lines.push("");
  lines.push("Please reply with your quotation (PDF or text) and include unit prices, lead times, and quality certificates.");
  lines.push("");
  lines.push("Regards, Procurement Team");

  return lines.join("\n");
};

/* NLP: extract RFP JSON from free text */
export const generateRFPFromText = async (text) => {
  const prompt = `
You are helping a procurement manager in an FMCG company.
Convert the following natural-language RFP into a structured JSON object.

Return ONLY JSON, no explanation, in this schema:

{
  "title": string,
  "description": string,
  "budget_amount": number | null,
  "budget_currency": string | null,
  "delivery_days": number | null,
  "payment_terms": string | null,
  "line_items": [
    {
      "name": string,
      "required_qty": number | null,
      "quality_spec": string | null
    }
  ],
  "notes": string | null
}

Natural language RFP:
"""${text}"""
`;

  try {
    const raw = await callGemini(prompt);
    const parsed = extractJson(raw);

    // normalize in case fields missing
    return {
      title: parsed.title || "RFP (Gemini Generated)",
      description: parsed.description || text,
      budget_amount: parsed.budget_amount ?? null,
      budget_currency: parsed.budget_currency || "INR",
      delivery_days: parsed.delivery_days ?? null,
      payment_terms: parsed.payment_terms || null,
      line_items: Array.isArray(parsed.line_items) ? parsed.line_items : [],
      notes: parsed.notes || null
    };
  } catch (err) {
    console.warn("⚠ Gemini RFP extraction failed, using fallback:", err.message);
    // safe fallback for your sugar + honey case
    return {
      title: "RFP (Fallback)",
      description: text,
      budget_amount: 1000000,
      budget_currency: "INR",
      delivery_days: 7,
      payment_terms: "Net 30",
      line_items: [
        { name: "Sugar", required_qty: 1000, quality_spec: "Grade B" },
        { name: "Honey", required_qty: 100, quality_spec: "Grade A" }
      ],
      notes: "Generated by fallback logic due to model error"
    };
  }
};


export const llmScoreVendor = async (rfp, vendorResponse) => {
  const prompt = `
You are a senior procurement expert for an FMCG company.

Evaluate the following vendor proposal strictly against the RFP:

--- RFP ---
${JSON.stringify(rfp, null, 2)}

--- Vendor Response ---
${JSON.stringify(vendorResponse, null, 2)}

Scoring rubric (0–100 total):
- Quality match vs required grade/spec: 40%
- Quantity fulfillment vs required quantity: 25%
- Delivery time vs delivery_days: 20%
- Price vs budget (lower is better): 10%
- Payment terms vs RFP payment_terms: 5%

Be strict and realistic: a vendor with wrong grade or very late delivery should get a low score.

Return ONLY JSON like this:

{
  "score": number,       // 0..100
  "reasons": [
    "short reason 1",
    "short reason 2"
  ]
}
`;

  try {
    const raw = await callGemini(prompt);
    const parsed = extractJson(raw);

    // basic sanity check
    return {
      score: typeof parsed.score === "number" ? parsed.score : 0,
      reasons: Array.isArray(parsed.reasons) ? parsed.reasons : ["No reasons provided by model"]
    };
  } catch (err) {
    console.warn("⚠ Gemini scoring failed, using fallback:", err.message);
    return {
      score: 50,
      reasons: ["Fallback scoring used due to AI error"]
    };
  }
};

